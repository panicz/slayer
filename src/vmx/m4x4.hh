#ifndef VMX_HH
#error "vmx/m4x4.hh should be included from vmx.hh"
#endif

template<typename S>
class m4x4 {
public:
  v4<S> c4[4];
  m4x4<S>(void); // initialize identity
  m4x4<S>(m3x3<S> A); // extend A with 0's 
  m4x4<S>(m3x3<S> A, v4<S> u4); // extend A with u4
  m4x4<S>(S r0c0, S r0c1, S r0c2, S r0c3,
	  S r1c0, S r1c1, S r1c2, S r1c3,
	  S r2c0, S r2c1, S r2c2, S r2c3,
	  S r3c0, S r3c1, S r3c2, S r3c3);
  m4x4<S>(v4<S> c40, v4<S> c41, v4<S> c42, v4<S> c43);
  v4<S>& operator[](unsigned int i);
  m4x4<S>& operator=(m4x4<S> A4);
  m4x4<S>& operator+=(m4x4<S> A4);
  m4x4<S>& operator-=(m4x4<S> A4);
  m4x4<S>& operator*=(S s);
  m4x4<S>& operator/=(S s);
  m4x4<S> T(void);
  m4x4<S> inv(void);
};
  
template<typename S>
inline m4x4<S>::m4x4(void) // initialize identity
{
  c4[0] = v4<S>(1,0,0,0);
  c4[1] = v4<S>(0,1,0,0);
  c4[2] = v4<S>(0,0,1,0);
  c4[3] = v4<S>(0,0,0,1);
}

template<typename S>
inline m4x4<S>::m4x4(m3x3<S> A) // extend A as below :)
{
  c4[0] = v4<S>(A[0], 0);
  c4[1] = v4<S>(A[1], 0);
  c4[2] = v4<S>(A[2], 0);
  c4[3] = v4<S>(0,0,0,1);
}

template<typename S>
inline m4x4<S>::m4x4(m3x3<S> A, v4<S> u4) // extend A with u4
{
  c4[0] = v4<S>(A[0], 0);
  c4[1] = v4<S>(A[1], 0);
  c4[2] = v4<S>(A[2], 0);
  c4[3] = u4;
}

template<typename S>
inline m4x4<S>::m4x4(S r0c0, S r0c1, S r0c2, S r0c3,
		     S r1c0, S r1c1, S r1c2, S r1c3,
		     S r2c0, S r2c1, S r2c2, S r2c3,
		     S r3c0, S r3c1, S r3c2, S r3c3)
{
  c4[0] = v4<S>(r0c0, r1c0, r2c0, r3c0);
  c4[1] = v4<S>(r0c1, r1c1, r2c1, r3c1);
  c4[2] = v4<S>(r0c2, r1c2, r2c2, r3c2);
  c4[3] = v4<S>(r0c3, r1c3, r2c3, r3c3);
}

template<typename S>
inline m4x4<S>::m4x4(v4<S> c40, v4<S> c41, v4<S> c42, v4<S> c43)
{
  c4[0] = c40;
  c4[1] = c41;
  c4[2] = c42;
  c4[3] = c43;
}

template<typename S>
inline v4<S>& m4x4<S>::operator[](unsigned int i)
{
  assert(i<4);
  return c4[i];
}

template<typename S>
inline m4x4<S>& m4x4<S>::operator=(m4x4<S> A4)
{
  c4[0] = A4[0];
  c4[1] = A4[1];
  c4[2] = A4[2];
  c4[3] = A4[3];
  return *this;
}

template<typename S>
inline m4x4<S>& m4x4<S>::operator+=(m4x4<S> A4)
{
  c4[0] += A4[0];
  c4[1] += A4[1];
  c4[2] += A4[2];
  c4[3] += A4[3];
  return *this;
}

template<typename S>
inline m4x4<S>& m4x4<S>::operator-=(m4x4<S> A4)
{
  c4[0] -= A4[0];
  c4[1] -= A4[1];
  c4[2] -= A4[2];
  c4[3] -= A4[3];
  return *this;
}

template<typename S>
inline m4x4<S>& m4x4<S>::operator*=(S s)
{
  c4[0] *= s;
  c4[1] *= s;
  c4[2] *= s;
  c4[3] *= s;
  return *this;
}

template<typename S>
inline m4x4<S>& m4x4<S>::operator/=(S s)
{
  assert(s != 0);
  s = 1/s;
  c4[0] *= s;
  c4[1] *= s;
  c4[2] *= s;
  c4[3] *= s;
  return *this;
}

template<typename S>
inline m4x4<S> m4x4<S>::T(void)
{
  return m4x4<S>(c4[0].x, c4[0].y, c4[0].z, c4[0].w,
		 c4[1].x, c4[1].y, c4[1].z, c4[1].w,
		 c4[2].x, c4[2].y, c4[2].z, c4[2].w,
		 c4[3].x, c4[3].y, c4[3].z, c4[3].w);
}

template<typename S, typename T> 
static inline m4x4<S> operator+(m4x4<S> A4, m4x4<T> B4)
{
  return m4x4<S>(A4[0] + B4[0],
		 A4[1] + B4[1],
		 A4[2] + B4[2],
		 A4[3] + B4[3]);
}

template<typename S, typename T> 
static inline m4x4<S> operator-(m4x4<S> A4, m4x4<T> B4)
{
  return m4x4<S>(A4[0] - B4[0],
		 A4[1] - B4[1],
		 A4[2] - B4[2],
		 A4[3] - B4[3]);
}

template<typename S, typename T> 
static inline m4x4<S> operator*(m4x4<S> A4, T s)
{
  return m4x4<S>(s*A4[0], s*A4[1], s*A4[2], s*A4[3]);
}

template<typename S, typename T> 
static inline m4x4<S> operator*(T s, m4x4<S> A4)
{
  return m4x4<S>(s*A4[0], s*A4[1], s*A4[2], s*A4[3]);
}

template<typename S, typename T> 
static inline m4x4<S> operator/(m4x4<S> A4, T s)
{
  assert(s!=0);
  s = 1/s;
  return m4x4<S>(s*A4[0], s*A4[1], s*A4[2], s*A4[3]);
}

template<typename S, typename T> 
static inline v4<S> operator*(m4x4<T> A4, v4<S> u4)
{
  return v4<S>(A4[0][0]*u4.x + A4[1][0]*u4.y + A4[2][0]*u4.z + A4[3][0]*u4.w,
	       A4[0][1]*u4.x + A4[1][1]*u4.y + A4[2][1]*u4.z + A4[3][1]*u4.w,
	       A4[0][2]*u4.x + A4[1][2]*u4.y + A4[2][2]*u4.z + A4[3][2]*u4.w,
	       A4[0][3]*u4.x + A4[1][3]*u4.y + A4[2][3]*u4.z + A4[3][3]*u4.w);
}

template<typename S, typename T> 
static inline v4<S> operator*(v4<S> u4, m4x4<T> A4)
{
  return v4<S>(u4*A4[0], u4*A4[1], u4*A4[2], u4*A4[3]);
}

template<typename S, typename T> 
static inline m3x3<S> operator*(m3x3<S> A, m3x3<T> B)
{
  return
    m3x3<S>(A[0][0]*B[0][0] + A[1][0]*B[0][1] + A[2][0]*B[0][2],
	    A[0][0]*B[1][0] + A[1][0]*B[1][1] + A[2][0]*B[1][2],
	    A[0][0]*B[2][0] + A[1][0]*B[2][1] + A[2][0]*B[2][2],
	    
	    A[0][1]*B[0][0] + A[1][1]*B[0][1] + A[2][1]*B[0][2],
	    A[0][1]*B[1][0] + A[1][1]*B[1][1] + A[2][1]*B[1][2],
	    A[0][1]*B[2][0] + A[1][1]*B[2][1] + A[2][1]*B[2][2],
	    
	    A[0][2]*B[0][0] + A[1][2]*B[0][1] + A[2][2]*B[0][2],
	    A[0][2]*B[1][0] + A[1][2]*B[1][1] + A[2][2]*B[1][2],
	    A[0][2]*B[2][0] + A[1][2]*B[2][1] + A[2][2]*B[2][2]);
}

template<typename S, typename T> 
static inline m4x4<S> operator*(m4x4<S> A, m4x4<T> B)
{
  return 
    m4x4<S>
    (A[0][0]*B[0][0] + A[1][0]*B[0][1] + A[2][0]*B[0][2] + A[3][0]*B[0][3],
     A[0][0]*B[1][0] + A[1][0]*B[1][1] + A[2][0]*B[1][2] + A[3][0]*B[1][3],
     A[0][0]*B[2][0] + A[1][0]*B[2][1] + A[2][0]*B[2][2] + A[3][0]*B[2][3],
     A[0][0]*B[3][0] + A[1][0]*B[3][1] + A[2][0]*B[3][2] + A[3][0]*B[3][3],
 
     A[0][1]*B[0][0] + A[1][1]*B[0][1] + A[2][1]*B[0][2] + A[3][1]*B[0][3],
     A[0][1]*B[1][0] + A[1][1]*B[1][1] + A[2][1]*B[1][2] + A[3][1]*B[1][3],
     A[0][1]*B[2][0] + A[1][1]*B[2][1] + A[2][1]*B[2][2] + A[3][1]*B[2][3],
     A[0][1]*B[3][0] + A[1][1]*B[3][1] + A[2][1]*B[3][2] + A[3][1]*B[3][3],

     A[0][2]*B[0][0] + A[1][2]*B[0][1] + A[2][2]*B[0][2] + A[3][2]*B[0][3],
     A[0][2]*B[1][0] + A[1][2]*B[1][1] + A[2][2]*B[1][2] + A[3][2]*B[1][3],
     A[0][2]*B[2][0] + A[1][2]*B[2][1] + A[2][2]*B[2][2] + A[3][2]*B[2][3],
     A[0][2]*B[3][0] + A[1][2]*B[3][1] + A[2][2]*B[3][2] + A[3][2]*B[3][3],

     A[0][3]*B[0][0] + A[1][3]*B[0][1] + A[2][3]*B[0][2] + A[3][3]*B[0][3],
     A[0][3]*B[1][0] + A[1][3]*B[1][1] + A[2][3]*B[1][2] + A[3][3]*B[1][3],
     A[0][3]*B[2][0] + A[1][3]*B[2][1] + A[2][3]*B[2][2] + A[3][3]*B[2][3],
     A[0][3]*B[3][0] + A[1][3]*B[3][1] + A[2][3]*B[3][2] + A[3][3]*B[3][3]);
  /* I did enjoy writing this routine */
}

template<typename S> 
static inline S det(m4x4<S> M)
{
  return 
    M[0][0]*det(m3x3<S>(M[1][1], M[2][1], M[3][1],
			M[1][2], M[2][2], M[3][2],
			M[1][3], M[2][3], M[3][3]))
    -
    M[0][1]*det(m3x3<S>(M[1][0], M[2][0], M[3][0],
			M[1][2], M[2][2], M[3][2],
			M[1][3], M[2][3], M[3][3]))
    +
    M[0][2]*det(m3x3<S>(M[1][0], M[2][0], M[3][0],
			M[1][1], M[2][1], M[3][1],
			M[1][3], M[2][3], M[3][3]))
    -
    M[0][3]*det(m3x3<S>(M[1][0], M[2][0], M[3][0],
			M[1][1], M[2][1], M[3][1],
			M[1][2], M[2][2], M[3][2]));
}

template<typename S>
inline m4x4<S> m4x4<S>::inv(void)
{
  S d = det(*this);
  assert(d!=0&&"inversion called on irreversible matrix");
  d = 1/d;
  return 
    m4x4<S>(//////////////////////////// 0 //////////////////////////
	    + c4[1][1]*c4[2][2]*c4[3][3] + c4[2][1]*c4[3][2]*c4[1][3]
	    + c4[3][1]*c4[1][2]*c4[2][3] - c4[1][1]*c4[3][2]*c4[2][3]
	    - c4[2][1]*c4[1][2]*c4[3][3] - c4[3][1]*c4[2][2]*c4[1][3],
	     
	    + c4[1][0]*c4[3][2]*c4[2][3] + c4[2][0]*c4[1][2]*c4[3][3]
	    + c4[3][0]*c4[2][2]*c4[1][3] - c4[1][0]*c4[2][2]*c4[3][3]
	    - c4[2][0]*c4[3][2]*c4[1][3] - c4[3][0]*c4[1][2]*c4[2][3],
		  
	    + c4[1][0]*c4[2][1]*c4[3][3] + c4[2][0]*c4[3][1]*c4[1][3]
	    + c4[3][0]*c4[1][1]*c4[2][3] - c4[1][0]*c4[3][1]*c4[2][3]
	    - c4[2][0]*c4[1][1]*c4[3][3] - c4[3][0]*c4[2][1]*c4[1][3],

	    + c4[1][0]*c4[3][1]*c4[2][2] + c4[2][0]*c4[1][1]*c4[3][2]
	    + c4[3][0]*c4[2][1]*c4[1][2] - c4[1][0]*c4[2][1]*c4[3][2]
	    - c4[2][0]*c4[3][1]*c4[1][2] - c4[3][0]*c4[1][1]*c4[2][2],

	    //////////////////////////// 1 //////////////////////////
	    + c4[0][1]*c4[3][2]*c4[2][3] + c4[2][1]*c4[0][2]*c4[3][3]
	    + c4[3][1]*c4[2][2]*c4[0][3] - c4[0][1]*c4[2][2]*c4[3][3]
	    - c4[2][1]*c4[3][2]*c4[0][3] - c4[3][1]*c4[0][2]*c4[2][3],
		  
	    + c4[0][0]*c4[2][2]*c4[3][3] + c4[2][0]*c4[3][2]*c4[0][3]
	    + c4[3][0]*c4[0][2]*c4[2][3] - c4[0][0]*c4[3][2]*c4[2][3]
	    - c4[2][0]*c4[0][2]*c4[3][3] - c4[3][0]*c4[2][2]*c4[0][3],
	     
	    + c4[0][0]*c4[3][1]*c4[2][3] + c4[2][0]*c4[0][1]*c4[3][3]
	    + c4[3][0]*c4[2][1]*c4[0][3] - c4[0][0]*c4[2][1]*c4[3][3]
	    - c4[2][0]*c4[3][1]*c4[0][3] - c4[3][0]*c4[0][1]*c4[2][3],

	    + c4[0][0]*c4[2][1]*c4[3][2] + c4[2][0]*c4[3][1]*c4[0][2]
	    + c4[3][0]*c4[0][1]*c4[2][2] - c4[0][0]*c4[3][1]*c4[2][2]
	    - c4[2][0]*c4[0][1]*c4[3][2] - c4[3][0]*c4[2][1]*c4[0][2],

	    //////////////////////////// 2 //////////////////////////
	    + c4[0][1]*c4[1][2]*c4[3][3] + c4[1][1]*c4[3][2]*c4[0][3]
	    + c4[3][1]*c4[0][2]*c4[1][3] - c4[0][1]*c4[3][2]*c4[1][3]
	    - c4[1][1]*c4[0][2]*c4[3][3] - c4[3][1]*c4[1][2]*c4[0][3],
	     
	    + c4[0][0]*c4[3][2]*c4[1][3] + c4[1][0]*c4[0][2]*c4[3][3]
	    + c4[3][0]*c4[1][2]*c4[0][3] - c4[0][0]*c4[1][2]*c4[3][3]
	    - c4[1][0]*c4[3][2]*c4[0][3] - c4[3][0]*c4[0][2]*c4[1][3],

	    + c4[0][0]*c4[1][1]*c4[3][3] + c4[1][0]*c4[3][1]*c4[0][3]
	    + c4[3][0]*c4[0][1]*c4[1][3] - c4[0][0]*c4[3][1]*c4[1][3]
	    - c4[1][0]*c4[0][1]*c4[3][3] - c4[3][0]*c4[1][1]*c4[0][3],
	     
	    + c4[0][0]*c4[3][1]*c4[1][2] + c4[1][0]*c4[0][1]*c4[3][2]
	    + c4[3][0]*c4[1][1]*c4[0][2] - c4[0][0]*c4[1][1]*c4[3][2]
	    - c4[1][0]*c4[3][1]*c4[0][2] - c4[3][0]*c4[0][1]*c4[1][2],

	    //////////////////////////// 3 //////////////////////////
	    + c4[0][1]*c4[2][2]*c4[1][3] + c4[1][1]*c4[0][2]*c4[2][3]
	    + c4[2][1]*c4[1][2]*c4[0][3] - c4[0][1]*c4[1][2]*c4[2][3]
	    - c4[1][1]*c4[2][2]*c4[0][3] - c4[2][1]*c4[0][2]*c4[1][3],

	    + c4[0][0]*c4[1][2]*c4[2][3] + c4[1][0]*c4[2][2]*c4[0][3]
	    + c4[2][0]*c4[0][2]*c4[1][3] - c4[0][0]*c4[2][2]*c4[1][3]
	    - c4[1][0]*c4[0][2]*c4[2][3] - c4[2][0]*c4[1][2]*c4[0][3],
	     
	    + c4[0][0]*c4[2][1]*c4[1][3] + c4[1][0]*c4[0][1]*c4[2][3]
	    + c4[2][0]*c4[1][1]*c4[0][3] - c4[0][0]*c4[1][1]*c4[2][3]
	    - c4[1][0]*c4[2][1]*c4[0][3] - c4[2][0]*c4[0][1]*c4[1][3],

	    + c4[0][0]*c4[1][1]*c4[2][2] + c4[1][0]*c4[2][1]*c4[0][2]
	    + c4[2][0]*c4[0][1]*c4[1][2] - c4[0][0]*c4[2][1]*c4[1][2]
	    - c4[1][0]*c4[0][1]*c4[2][2] - c4[2][0]*c4[1][1]*c4[0][2]);
}

#ifdef USE_IOSTREAM
template<typename S> 
static inline std::ostream& operator<<(std::ostream& os, m4x4<S> M)
{
  return os 
    << "/"<<M[0][0]<<" "<<M[1][0]<<" "<<M[2][0]<<" "<<M[3][0]<<"\\\n"
    << "|"<<M[0][1]<<" "<<M[1][1]<<" "<<M[2][1]<<" "<<M[3][1]<< "|\n"
    << "|"<<M[0][2]<<" "<<M[1][2]<<" "<<M[2][2]<<" "<<M[3][2]<< "|\n"
    <<"\\"<<M[0][3]<<" "<<M[1][3]<<" "<<M[2][3]<<" "<<M[3][3]<< "/\n";
}
#endif
