\input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename slayer.info
@documentencoding UTF-8
@settitle SLAYER
@paragraphident 0
@iftex
@afourpaper
@end iftex
@c %**end of header

@include version.texi

@dircategory The Algorithmic Language Scheme
@direntry
* SLAYER: (slayer).     Multimedia programming platform for Guile Scheme.
@end direntry

@copying
Copyright @copyright{} 2013 Panicz Maciej Godek

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the appendix entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@c --- title page starts here ---

@titlepage
@title SLAYER
@subtitle Multimedia programming platform for Guile Scheme
@subtitle Version @value{VERSION}
@author Panicz Maciej Godek

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c --- title page ends here ---

@contents

@syncodeindex vr cp
@syncodeindex fn cp

@node Top
@top The Slayer Platform

@ifinfo
This manual documents SLAYER @value{VERSION} package, which provides 
an event-driven SDL-based@footnote{@uref{http://www.libsdl.org}} multimedia 
framework in Guile Scheme@footnote{@uref{http://www.gnu.org/software/guile}} 
for displaying and editing multimedia content, including images (through 
SDL_image), sounds (through SDL_mixer) and 3d-graphics (through OpenGL). 
It comes shipped with a plug-in which wraps Open Dynamics 
Engine@footnote{@uref{http://www.ode.org}} and provides a simplified
and relatively natural interface to rigid body simulations in Scheme.

This manual is
@insertcopying
@end ifinfo

@menu
* Introduction::                What exactly is SLAYER and what
                                can it do for you
* Direct Layer::                The basic event-driven model of control

* Widgets::                     Higher-level framework for convinient
                                GUI development
* Plug-ins (SCUM)::             Slayer Convinient Utility Modules

* Looking ahead::               Further development of SLAYER

* GNU FDL::                     Copying and sharing this documentation
* Index::
@end menu


@node Introduction
@chapter Introduction
When I was 14, I felt a desperate urge to program computer games. I collected
$25 to buy a book that would teach me programming. It was a huge brick titled
``Teach yourself Visual Basic 6.0 in 21 days'', and I soon figured out that 
I'd need $1000 more to obtain the tools that would allow me to use the 
knowledge contained in the book. That I could not afford.

Times have changed a lot since then. Windows 95 is no longer a dictator
on desktop computers, there are many excellent free tools and libraries 
for developers (often much better than the proprietary ones), and knowledge 
on the Web is available to virtually everyone.

However, many tools are much more difficult to learn than they could be, or
aren't available on as many systems as one could wish. Furthermore, existing
soultions frequently impose many restrictions on the way the things can be done.

SLAYER was conceived to address those issues. It is meant to be an accessible,
portable and extensible multimedia environment that would be suitable for
learning as well as game development and unconventional or highly customizable 
GUI/multimedia applications. It uses SDL for portability and is built on top 
of Guile Scheme for accessibility and extensibility.

In a way SLAYER can resemble fluxus@footnote{@uref{www.pawfal.org/fluxus/}}.
There are however some essential differences between those systems. Fluxus
is intended to work mainly with 3D-graphics, while SLAYER works with 2D
objects just as fine. Fluxus has a built-in editor, while SLAYER is kept
minimalistic and only allows to add an editor widget to the stage, which 
perhaps makes it more flexible. (By the way, such widget is already provided
and used in one of the demos.) Also, fluxus is focused on live coding and 
sound processing, but there are no good sound processing libraries for SLAYER
yet.

Lastly, SLAYER works with Guile Scheme, and fluxus uses Racket. These are
both Scheme-based languages, but their extensions are incompatible with each
other. They're both cool, though.

@menu
* Getting started::             An implementation of a simple image browsing
                                application
* Invoking SLAYER::             A detailed description of command line 
                                arguments

@end menu

@node Simple example
This section assumes that SLAYER is already installed and properly configured
on your system, and that you are familiar with programming in general, and 
Guile Scheme in particular.

To get the grasp on how SLAYER works, we'll create a simple application for
browsing images@footnote{The idea for this program was inspired by Thien-Thi
Nguyen, who placed a similar program in the manual for the Guile-SDL package}. 

In order to do so, we need to create a text file; let's call it 
``image-browser.scm''@footnote{SLAYER uses Scheme programming language, so 
it is convinient to name files with .scm extension, because various editors 
can detect that and load appropreate editing mode}. Let's fill the file with
the following content:

@pindex Image browser
@lisp
(use-modules (slayer) (slayer image) (extra common))
(keydn 'esc quit)

(define *image-names* (shell "ls ../demos/art/*.png"))
(define *number-of-images* (length *image-names*))
(define *current-image* #f)
(define *image-index* 0)

(if (<= *number-of-images* 0)
    (die "no images found"))

(set-display-procedure! (lambda () (draw-image! *current-image* 0 0)))

(define (show-image! i)
  (set! *image-index* (modulo i *number-of-images*))
  (let ((image-name (list-ref *image-names* *image-index*)))
    (set! *current-image* (load-image image-name))
    (apply set-screen-size! (image-size *current-image*))
    (set-window-title! image-name)))

(show-image! 0)

(keydn 'left (lambda () (show-image! (+ *image-index* 1))))
(keydn 'right (lambda () (show-image! (- *image-index* 1))))
@end lisp

In order to execute the program, one shall type
$ slayer -i image-browser.scm

@findex shell
The @code{(extra common)} module contains definitions and evocations of
various useful procedures and macros, among which there is @code{shell}
procedure (which behaves like @code{system}, except that it returns a list
containing the lines written to standard output) and @code{match-let*} macro,
re-exported from the @code{(ice-9 match)} module.

@findex set-display-procedure!
The argument to @code{set-display-procedure!} is executed after a series of
events has been processed -- so evey time an event occurs (like keyboard or
mouse input, or window resize, or timer event), the whole screen is wiped
and its content is displayed on the screen from scratch.

While this might seem a waste of resources, this is a desired behaviour for
the class of applications that SLAYER aims to deliver, i.e. 3d games and
real-time multimedia processing apps. Since the input can be gathered during
the redisplay stage, the applications generally tend to be responsive.

@node Invoking SLAYER



@node Direct Layer
@chapter Direct Layer
In order to make SLAYER useful, you need to attach event handlers to certain
events. If you are willing to create a real-time simulation, you may also wish 
to run a timer that generates its own events.
In this chapter, you will find a description of all procedures available
directly from SLAYER, divided into three groups:

* Input handling and screen management::
* Loading and processing fonts, images and sounds::
* Diving into 3D graphics::

@node Input handling and screen management
Once SLAYER is up and running, it has one window where everything is
displayed, and which gathers all the input. If you want to use procedures
described here, you need to @code{(use-modules (slayer))}.

In order to get something displayed on the screen, you need to set a display
procedure of your liking.
@deffn {Procedure} set-display-procedure! thunk
Sets @var{thunk} to be called after each series of events is handled and the
screen is wiped.
@end deffn

@deffn {Procedure} screen-size
Return a list containing width and height of the window, in pixels.
@end deffn

@deffn {Procedure} set-screen-size! width height
Set the screen size to @var{width} times @var{height} pixels. It causes
a screen resize event, which can be handled using @code{set-resize-procedure!}.
@end deffn

@deffn {Procedure} set-resize-procedure! proc
Sets the binary procedure @var{proc} to be invoked on window resize event.
@var{proc} takes two arguments, namely -- the new width and height of the screen.
@end deffn

@deffn {Procedure} set-exit-procedure! proc
Sets the @var{proc} procedure to be called on exit. Due to historical reasons,
@var{proc} currently takes one argument, which should be ignored.
@end deffn

@deffn {Procedure} set-window-title! string
Sets the window caption to @var{string}. This can only be visible if SLAYER
is run in a window manager, in non-fullscreen mode.
@end deffn



@node Loading and processing fonts, images and sounds

@node Diving into 3D graphics


@node Widgets
@chapter Widgets

@node Plug-ins (SCUM)
@chapter Plug-ins (SCUM)

@node Looking ahead
@chapter Looking ahead


