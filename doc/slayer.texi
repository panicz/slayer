\input texinfo
@c -*-texinfo-*-
@c %**start of header
@setfilename slayer.info
@documentencoding UTF-8
@settitle SLAYER
@paragraphident 0
@iftex
@afourpaper
@end iftex
@c %**end of header

@include version.texi

@dircategory The Algorithmic Language Scheme
@direntry
* SLAYER: (slayer).     Multimedia programming platform for Guile Scheme.
@end direntry

@copying
Copyright @copyright{} 2013 Panicz Maciej Godek

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
Texts.  A copy of the license is included in the appendix entitled
``GNU Free Documentation License''.
@end quotation
@end copying

@c --- title page starts here ---

@titlepage
@title SLAYER
@subtitle Multimedia programming platform for Guile Scheme
@subtitle Version @value{VERSION}
@author Panicz Maciej Godek

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c --- title page ends here ---

@contents

@syncodeindex vr cp
@syncodeindex fn cp

@node Top
@top The Slayer Platform

@ifinfo
This manual documents SLAYER @value{VERSION} package, which provides 
an event-driven SDL-based@footnote{@uref{http://www.libsdl.org}} multimedia 
framework in Guile Scheme@footnote{@uref{http://www.gnu.org/software/guile}} 
for displaying and editing multimedia content, including images (through 
SDL_image), sounds (through SDL_mixer) and 3d-graphics (through OpenGL). 
It comes shipped with a plug-in which wraps Open Dynamics 
Engine@footnote{@uref{http://www.ode.org}} and provides a simplified
and relatively natural interface to rigid body simulations in Scheme.

This manual is
@insertcopying
@end ifinfo

@menu
* Introduction::                What exactly is SLAYER and what
                                can it do for you
* Direct Layer::                The basic event-driven model of control

* Widgets::                     Higher-level framework for convinient
                                GUI development
* Plug-ins (SCUM)::             Slayer Convinient Utility Modules

* Looking ahead::               Further development of SLAYER

* GNU FDL::                     Copying and sharing this documentation
* Index::
@end menu


@node Introduction
@chapter Introduction
When I was 14, I felt a desperate urge to program computer games. I collected
$25 to buy a book that would teach me programming. It was a huge brick titled
``Teach yourself Visual Basic 6.0 in 21 days'', and I soon figured out that 
I'd need $1000 more to obtain the tools that would allow me to use the 
knowledge contained in the book. That I could not afford.

Times have changed a lot since then. Windows 95 is no longer a dictator
on desktop computers, there are many excellent free tools and libraries 
for developers (often much better than the proprietary ones), and knowledge 
on the Web is available to virtually everyone.

However, many tools are much more difficult to learn than they could be, or
aren't available on as many systems as one could wish. Furthermore, existing
soultions frequently impose many restrictions on the way the things can be done.

SLAYER was conceived to address those issues. It is meant to be an accessible,
portable and extensible multimedia environment that would be suitable for
learning as well as game development and unconventional or highly customizable 
GUI/multimedia applications. It uses SDL for portability and is built on top 
of Guile Scheme for accessibility and extensibility.

In a way SLAYER can resemble fluxus@footnote{@uref{www.pawfal.org/fluxus/}}.
There are however some essential differences between those systems. Fluxus
is intended to work mainly with 3D-graphics, while SLAYER works with 2D
objects just as fine. Fluxus has a built-in editor, while SLAYER is kept
minimalistic and only allows to add an editor widget to the stage, which 
perhaps makes it more flexible. (By the way, such widget is already provided
and used in one of the demos.) Also, fluxus is focused on live coding and 
sound processing, but there are no good sound processing libraries for SLAYER
yet.

Lastly, SLAYER works with Guile Scheme, and fluxus uses Racket. These are
both Scheme-based languages, but their extensions are incompatible with each
other. They're both cool, though.

@menu
* Getting started::             An implementation of a simple image browsing
                                application
* Invoking SLAYER::             A detailed description of command line 
                                arguments

@end menu

@node Simple example
This section assumes that SLAYER is already installed and properly configured
on your system, and that you are familiar with programming in general, and 
Guile Scheme in particular.

To get the grasp on how SLAYER works, we'll create a simple application for
browsing images@footnote{The idea for this program was inspired by Thien-Thi
Nguyen, who placed a similar program in the manual for the Guile-SDL package}.

In order to do so, we need to create a text file; let's call it 
``image-browser.scm''@footnote{SLAYER uses Scheme programming language, so 
it is convinient to name files with .scm extension, because various editors 
can detect that and load appropreate editing mode}. Let's fill the file with
the following content:

@pindex Image browser
@lisp
(use-modules (slayer) (slayer image) (ice-9 popen) (ice-9 rdelim))
(keydn 'esc quit)

(define (shell command)
  (let ((pipe (open-pipe command OPEN_READ)))
    (let loop ((lines '())
	       (line (read-line pipe)))
      (cond ((eof-object? line)
	     (close-pipe pipe)
	     (reverse lines))
	    (else
	     (loop (cons line lines)
		   (read-line pipe)))))))

(define *image-names* (shell "ls ../demos/art/*.png"))
(define *number-of-images* (length *image-names*))
(define *current-image* #f)
(define *image-index* 0)

(if (<= *number-of-images* 0)
    (die "no images found"))
    
(set-display-procedure! (lambda () (draw-image! *current-image* 0 0)))

(define (show-image! i)
  (set! *image-index* (modulo i *number-of-images*))
  (let ((image-name (list-ref *image-names* *image-index*)))
    (set! *current-image* (load-image image-name))
    (apply set-screen-size! (image-size *current-image*))
    (set-window-title! image-name)))

(show-image! 0)

(keydn 'left (lambda () (show-image! (+ *image-index* 1))))
(keydn 'right (lambda () (show-image! (- *image-index* 1))))
@end lisp

In order to execute the program, one shall type
$ slayer -i image-browser.scm

@findex set-display-procedure!
The argument to @code{set-display-procedure!} is executed after a series of
events has been processed -- so evey time an event occurs (like keyboard or
mouse input, or window resize, or timer event), the whole screen is wiped
and its content is displayed on the screen from scratch.

While this might seem a waste of resources, this is a desired behaviour for
the class of applications that SLAYER aims to deliver, i.e. 3d games and
real-time multimedia processing apps. Since the input can be gathered during
the redisplay stage, the applications generally tend to be responsive.

@node Invoking SLAYER
Type ``slayer --help'' to get the list of possible options.
(TODO: this section definitely requires some elaboration)

@node Direct Layer
@chapter Direct Layer
In order to make SLAYER useful, you need to attach event handlers to certain
events. If you are willing to create a real-time simulation, you may also wish 
to run a timer that generates its own events.
In this chapter, you will find a description of all procedures available
directly from SLAYER, divided into three groups:

* Input handling and screen management::
* Loading and processing fonts, images and sounds::
* Diving into 3D graphics::

@node Input handling and screen management
Once SLAYER is up and running, it has one window where everything is
displayed, and which gathers all the input. If you want to use procedures
described here, you need to @code{(use-modules (slayer))}.

In order to get something displayed on the screen, you need to set a display
procedure of your liking.
@deffn {Procedure} set-display-procedure! thunk
Sets @var{thunk} to be called after each series of events is handled and the
screen is wiped.
@end deffn

@deffn {Procedure} screen-size
Return a list containing width and height of the window, in pixels.
@end deffn

@deffn {Procedure} set-screen-size! width height
Set the screen size to @var{width} times @var{height} pixels. It causes
a screen resize event, which can be handled using @code{set-resize-procedure!}.
@end deffn

@deffn {Procedure} set-resize-procedure! proc
Sets the binary procedure @var{proc} to be invoked on window resize event.
@var{proc} takes two arguments, namely -- the new width and height of the screen.
@end deffn

@deffn {Procedure} set-exit-procedure! proc
Sets the @var{proc} procedure to be called on exit. Due to historical reasons,
@var{proc} currently takes one argument, which should be ignored.
@end deffn

@deffn {Procedure} set-window-title! string
Sets the window caption to @var{string}. This can only be visible if SLAYER
is run in a window manager, in non-fullscreen mode.
@end deffn

@deffn {Procedure} keydn key thunk
Set @var{thunk} to be invoked whenever @var{key} is pressed (including mouse
buttons). @var{key} can either be a string or a symbol. See the @xref{Key names}
table to get the names of specific keys.
@end deffn

@deffn {Procedure} keyup key thunk
This function works exactly as @code{keydn}, except that the @var{thunk} is
invoked on @var{key} release.
@end deffn

@deffn {Procedure} mousemove proc
Set @var{proc} to be invoked whenever mouse is moved. @var{proc} takes four
arguments: @code{(x y dx dy)}, where @code{(x y)} is the current mouse position
and @code{(dx dy)} is the difference between the previous and the current
position.
@end deffn

@deffn {Procedure} modifier-pressed? modifier
Checks whether @var{modifier} is pressed. @var{modifier} is a symbol that
can be either @code{shift}, @code{rshift}, @code{lshift}, @code{alt},
@code{lalt}, @code{ralt}, @code{ctrl}, @code{lctrl}, @code{rctrl}, @code{meta}, 
@code{lmeta}, @code{rmeta}.
@end deffn

@deffn {Procedure} input-mode
Return the symbol describing current input mode, which can either be 
@code{'typing} or @code{'direct}. Direct mode is the default for SLAYER.
@end deffn

@deffn {Procedure} set-direct-input-mode!
Sets the input mode to ``direct'', which means that events are generated only
when keys are actually pressed, which is the desired behaviour for most games,
and the default behaviour of SLAYER.
@end deffn

@deffn {Procedure} set-typing-input-mode!
Sets the input mode to ``typing'', which means that the keyboard input behaves
like when typing in an editor -- once a key is pressed, after a certain time
it gets repeated at a certain frequency. In typing mode, pressing printable
characters do not cause the procedures specified with @code{keydn} and 
@code{keyup} to be called; instead, it causes the typed character to be written
to current output port, or it invokes a procedure specified with
@code{set-typing-special-procedure!} to be called with the pressed special key
name as argument.
@end deffn

@deffn {Procedure} set-typing-special-procedure! proc
When in typing mode, @var{proc} will be called whenever a special (i.e.
non-printable, e.g. return, escape of F1) key is pressed or repeated.
@var{proc} will receive one argument: the name of the special key that
was pressed (as a string).
@end deffn

@deffn {Procedure} grab-input! state
If @var{state} is given and not @code{#f}, the procedure causes the SLAYER
window to grab all the keyboard and mouse input. This can be deactivated
and brought back to normal by passing @code{#f} as @var{state}.
When @var{state} is not given, the procedure only returns the current state.
@end deffn

@deffn {Procedure} register-userevent proc
Register a new user event. The @var{proc} procedure will be called with zero,
one or two arguments, depending on the way the corresponding
@code{generate-userevent} procedure is called. @code{register-userevent}
returns an identifier of user event (which happens to be an integer). Up to
255 user events can be registered.
@end deffn

@deffn {Procedure} generate-userevent identifier [data1] [data2]
Generate user event identified with @code{identifier}, obtained with a previous 
call to @code{register-userevent}. The @var{data1} and @var{data2} arguments
are passed to event handler if provided.
@end deffn

* Key names::
* Implementing persistent input::

@node Key names
The names of the keys are usually rather intuitive: 'a names the key A, 
"1" names the key 1, and so on. Note that, although usually the names can be
given as symbols, in some cases the string representation is required, like
in the case of digits, punctuation marks or brackets.
Note also, that not all these characters will be accessible through the
event subsystem in direct mode (it should depend on the keyboard layout):
for instance, if exclamation mark is obtained by pressing shift and '1'
(in typing mode), only the events related with pressing shift and '1' will
be generated (in direct mode).

   SLAYER NAME                 ASCII VALUE              COMMON NAME (SDL)

   "mouse1"                                             left mouse button
   "mouse2"                                             right mouse button
   "mouse3"                                             middle mouse button
   "mwheelup"                                           mouse wheel up
   "mwheeldown"                                         mouse wheel down

   "backspace"                 '\b'                     backspace
   "tab"                       '\t'                     tab
   "clear"                                              clear
   "return"                    '\r'                     return
   "pause"                                              pause
   "esc"                       '^['                     escape
   "space"                     ' '                      space
   "!"                         '!'                      exclaim
   "\""                        '"'                      quotedbl
   "#"                         '#'                      hash
   "$"                         '$'                      dollar
   "&"                         '&'                      ampersand
   "'"                         '''                      quote
   "("                         '('                      left parenthesis
   ")"                         ')'                      right parenthesis
   "*"                         '*'                      asterisk
   "+"                         '+'                      plus sign
   "-"                         '-'                      minus sign
   ","                         ','                      comma
   "."                         '.'                      period
   "/"                         '/'                      forward slash
   "0"                         '0'                      0
   "1"                         '1'                      1
   "2"                         '2'                      2
   "3"                         '3'                      3
   "4"                         '4'                      4
   "5"                         '5'                      5
   "6"                         '6'                      6
   "7"                         '7'                      7
   "8"                         '8'                      8
   "9"                         '9'                      9
   ":"                         ':'                      colon
   ";"                         ';'                      semicolon
   "<"                         '<'                      less-than sign
   "="                         '='                      equals sign
   ">"                         '>'                      greater-than sign
   "?"                         '?'                      question mark
   "@"                         '@'                      at
   "["                         '['                      left bracket
   "\\"                        '\'                      slash
   "]"                         ']'                      right bracket
   "^"                         '^'                      caret
   "_"                         '_'                      underscore
   "`"                         '`'                      grave
   "a"                         'a'                      a
   "b"                         'b'                      b
   "c"                         'c'                      c
   "d"                         'd'                      d
   "e"                         'e'                      e
   "f"                         'f'                      f
   "g"                         'g'                      g
   "h"                         'h'                      h
   "i"                         'i'                      i
   "j"                         'j'                      j
   "k"                         'k'                      k
   "l"                         'l'                      l
   "m"                         'm'                      m
   "n"                         'n'                      n
   "o"                         'o'                      o
   "p"                         'p'                      p
   "q"                         'q'                      q
   "r"                         'r'                      r
   "s"                         's'                      s
   "t"                         't'                      t
   "u"                         'u'                      u
   "v"                         'v'                      v
   "w"                         'w'                      w
   "x"                         'x'                      x
   "y"                         'y'                      y
   "z"                         'z'                      z
   "delete"                    '^?'                     delete
   "num0"                                               keypad 0
   "num1"                                               keypad 1
   "num2"                                               keypad 2
   "num3"                                               keypad 3
   "num4"                                               keypad 4
   "num5"                                               keypad 5
   "num6"                                               keypad 6   
   "num7"                                               keypad 7
   "num8"                                               keypad 8
   "num9"                                               keypad 9
   "num."                      '.'                      keypad period
   "num/"                      '/'                      keypad divide
   "num*"                      '*'                      keypad multiply
   "num-"                      '-'                      keypad minus
   "num+"                      '+'                      keypad plus
   "numret"                    '\r'                     keypad enter
   "numeql"                    '='                      keypad equals
   "up"                                                 up arrow
   "down"                                               down arrow
   "left"                                               left arrow
   "right"                                              right arrow
   "ins"                                                insert
   "home"                                               home
   "end"                                                end
   "pgup"                                               page up
   "pgdown"                                             page down
   "f1"                                                 F1
   "f2"                                                 F2
   "f3"                                                 F3
   "f4"                                                 F4
   "f5"                                                 F5
   "f6"                                                 F6
   "f7"                                                 F7
   "f8"                                                 F8
   "f9"                                                 F9
   "f10"                                                F10
   "f11"                                                F11
   "f12"                                                F12
   "f13"                                                F13
   "f14"                                                F14
   "f15"                                                F15
   "numlock"                                            numlock
   "caps"                                               capslock
   "scroll"                                             scrollock
   "lshift"                                             left shift
   "rshift"                                             right shift
   "lctrl"                                              left ctrl
   "rctrl"                                              right ctrl
   "lalt"                                               left alt
   "ralt"                                               right alt
   "lmeta"                                              left meta
   "rmeta"                                              right meta
   "lsuper"                                             left windows key
   "rsuper"                                             right windows key
   "mode"                                               mode shift
   "help"                                               help
   "print"                                              print screen
   "sysrq"                                              SysRq
   "break"                                              break
   "menu"                                               menu
   "power"                                              power
   "euro"                                               euro

@node Implementing persistent input
The @code{keydn} and @code{keyup} procedures register event handlers that are
called whenever a certain key is pressed or released. It can sometimes be
desired, however, to call a certain procedure ``persistently'', i.e. as long
as a given key is pressed.

SLAYER itself doesn't provide such functions, because they frequently depend
on a specific application. However, this document provides a general solution
that can be taylored to one's needs. The purpose is not only to show how the
feature can be implemented, but also to set the paradigm, which perhaps would 
make any future programs easier to read. It also shows how to use the
@code{register-userevent} and @code{generate-userevent} procedures.

@pindex Persistent input
@lisp
(use-modules (slayer))

;; first, we might find it useful to have a timer, which would generate
;; an event from time to time, and sleep for the most of the time, in an
;; infinite loop

(define-syntax-rule (utimer usecs action ...)
  (let ((tick (register-userevent (lambda () action ...))))
    (call-with-new-thread (lambda () (while #t
				       (generate-userevent tick)
				       (usleep usecs))))))

;; we need to keep track on which keys are pressed, in the *modes* hash table.
;; its keys are the names of pressed keys, and values -- the procedures that
;; are meant to be called "persistently"

(define *modes* (make-hash-table))

;; we also need to be able to define a procedure to be called as long as the
;; key is pressed

(define (key name proc)
  (keydn name (lambda()(hash-set! *modes* name proc)))
  (keyup name (lambda()(hash-remove! *modes* name))))

;; lastly, we shall invoke procedures corresponding to the pressed keys with
;; a certain regularity, say, 30000 micro-seconds:

(utimer 30000 (hash-for-each (lambda(key thunk)(thunk)) *modes*))

;; now we can bind keys to persistent procedures:
(key 'return 
     (lambda ()
        (display (string-append "this message will be printed"
                                " for as long as 'return is pressed\n"))))
@end lisp

@node Loading and processing fonts, images and sounds
When creating a multimedia application, it is inevitable to work with external
data, such as sounds and images. It can also be strongly desired to be able to 
render text to images and display it on the screen.

The following sections describe how to perform those activities in SLAYER.

* Loading and displaying images::              (slayer image)
* Rendering and displaying text::              (slayer font)
* Loading and playing sounds::

@node Loading and displaying images

In order to be able to use the procedures documented here, one shall 
@code{(use-modules (slayer image))}.

@deffn {Procedure} load-image path
Loads an image from an external file, indicated by @var{path}. The supported 
file formats depend on the way the SDL_image library was compiled. The procedure
returns an object that represents the image internally, and can be used with
@code{draw-image!} and other procedures.
FIXME: if something goes wrong (i.e. the file doesn't exist), the application
will probably crash.
@end deffn

@deffn {Procedure} draw-image! image x y
Display @var{image} on the screen. Its top left corner will be located at
(@var{x}, @var{y}).
@end deffn

@deffn {Procedure} rectangle w h color
Generates and returns solid rectangle whose width is @var{w}, height @var{h} and 
color is @var{color}. @var{color} is a 32-bit integer value, which can be 
written as @code{#xAARRGGBB}, where @code{AA} means alpha channel, @code{RR} 
is red component, @code{GG} -- green component, and @code{BB} -- blue component.
@end deffn

@deffn {Procedure} image-size image
Returns @code{(width height)} of the @var{image}.
@end

@deffn {Procedure} image->array image
Converts @var{image} to two-dimensional uniform array of integers.
@end deffn

@deffn {Procedure} array->image array
Converts two-dimensional uniform @var{array} of integers to image.
@end deffn

@node Rendering and displaying text
In order to be able to use the procedures documented here, one shall 
@code{(use-modules (slayer font))}.

@deffn {Procedure} load-font path pt-size
Load TrueType font from a file indicated by @var{path}. The size of the font
will be @var{pt-size}. Returns the object representing font, which can later
be used for rendering text using @code{render-text} procedure.
@end deffn

@deffn {Procedure} render-text text font [color] [bgcolor]
Returns a new image containing @var{text} rendered using @var{font} with
@var{color} (which defaults to white). If @var{bgcolor} is given, it will
become the background color of the image; otherwise, the background is
transparent.
The obtained image can be displayed on the screen using @code{draw-image!}.
@end deffn

@deffn {Procedure} font-line-skip font
Returns the line skip (integer) defined by the @var{font}.
@end

@node Loading and playing sounds


@node Diving into 3D graphics


@node Widgets
@chapter Widgets

@node Plug-ins (SCUM)
@chapter Plug-ins (SCUM)

@node Looking ahead
@chapter Looking ahead


