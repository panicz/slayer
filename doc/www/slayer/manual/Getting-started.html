<html lang="en">
<head>
<title>Getting started - SLAYER</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="SLAYER">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Introduction.html#Introduction" title="Introduction">
<link rel="next" href="Invoking-SLAYER.html#Invoking-SLAYER" title="Invoking SLAYER">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2013 Panicz Maciej Godek

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the appendix entitled ``GNU Free Documentation License''.
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Getting-started"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Invoking-SLAYER.html#Invoking-SLAYER">Invoking SLAYER</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Introduction.html#Introduction">Introduction</a>
<hr>
</div>

<h3 class="section">1.1 Getting started</h3>

<p>This section assumes that SLAYER is already installed and properly configured
on your system, and that you are familiar with programming in general, and
Guile Scheme in particular.

<p>To get the grasp on how SLAYER works, we'll create a simple application for
browsing images<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>.

<p>In order to do so, we need to create a text file; let's call it
&ldquo;image-browser.scm&rdquo;<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>. Let's fill the file with
the following content:

<p><a name="index-Image-browser-1"></a>
<pre class="lisp">     (use-modules (slayer) (slayer image)
     	     (srfi srfi-1) (srfi srfi-2))
     (keydn 'esc quit)
     
     (define (list-directory path)
       (let ((dir (opendir path)))
         (unfold eof-object? (lambda(f)(string-append path f))
     	    (lambda x (readdir dir)) (readdir dir))))
     
     (define (file? f) (eq? 'regular (stat:type (stat f))))
     
     (define *directory* (if (defined? '$1) $1 "/usr/share/pixmaps/"))
     (define *image-names* (filter file? (list-directory *directory*)))
     (define *current-image* #f)
     (define *image-index* 0)
     
     (if (&lt;= (length *image-names*) 0)
         (begin (display "no images found\n") (quit)))
     
     (set-display-procedure! (lambda () (draw-image! *current-image* 0 0)))
     
     (define (show-image! i)
       (set! *image-index* (modulo i (length *image-names*)))
       (and-let* ((image-name (list-ref *image-names* *image-index*))
     	     (image (load-image image-name)))
         (set! *current-image* image)
         (apply set-screen-size! (image-size *current-image*))
         (set-window-title! image-name)))
     
     (show-image! 0)
     
     (keydn 'left (lambda () (show-image! (+ *image-index* 1))))
     (keydn 'right (lambda () (show-image! (- *image-index* 1))))
</pre>
<p>In order to execute the program, one shall type:

<p><code>$ slayer image-browser.scm</code>

<p><a name="index-set_002ddisplay_002dprocedure_0021-2"></a>The argument to <code>set-display-procedure!</code> is executed after a series of
events has been processed &ndash; so evey time an event occurs (like keyboard or
mouse input, or window resize, or timer event), the whole screen is wiped
and its content is displayed on the screen from scratch.

<p>While this might seem a waste of resources, this is a desired behaviour for
the class of applications that SLAYER aims to deliver, i.e. 3d games and
real-time multimedia processing apps. Since the input can be gathered during
the redisplay stage, the applications generally tend to be responsive.

<div class="footnote">
<hr>
<h4>Przypisy</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> The idea for this program was inspired by Thien-Thi
Nguyen, who placed a similar program in the manual for the Guile-SDL package</p>

<p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> SLAYER uses Scheme programming language, so
it is convinient to name files with .scm extension, because various editors
can detect that and load appropreate editing mode</p>

<hr></div>

</body></html>

