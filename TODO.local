Kolejne kroki




cel nadrzedny: stworzyc projekt robota humanoidalnego
srodki (cele posrednie):
- obsluga trimeshow z ODE
- wyswietlanie trimeshow
  - obsluga swiatel
    - wektory normalne
    - ustawianie wlasnosci swiatel
    - kolejnosc: czy trzeba ustawic swiatla przed wyrenderowaniem sceny?
- zaprojektowanie modeli (poszczegolnych czesci)
- polaczenie czesci ze soba
- dodanie opcji przesuwania i obracania rigow przy ich instancjalizacji

- rozkminić kwestię sterowania (położeniowego) oraz macierzowy opis stanu
więzów (chcemy mieć takie cudo, że podajemy okreslony stan, a sterownik sam
wylicza optymalne sterowanie, mając na względzie wielorakie sprzężenia zwrotne
itd -- czyli sterowaniem winna być macierz położeniowa, albo cos takiego)

- skonstruować to cacuszko, że jak się klika na łidżet, to znajduje ciało,
które zostało zaklikłe (podobno gluUnproject jakoś w tym pomaga)
-- to już jest jako tako rozstrzygnięte; ewentualnie można zrobić coś takiego,
że jak się kliknie na jakieś ciało, to jest przenoszone do specjalnej przestrzeni
bez detekcji kolizji ani grawitacji, i rusza się zgodnie z ruchami myszy



DOKUMENTACJA:

- wprowadzenie
  - czym jest slayer?
  - dlaczego guile?
  - kwestia wyda3jności

- opis warstwy bezpośredniej (slayer)
  - stabilność
  - ładowalne moduły (font, image, audio)

- opis widgetów (unstable)

- opis plug-inow

- plany na przyszłość
  - "emacs dla multimediów"
  - repozytorium scumbag?


PILNIEJSZE:
uporzadkowac system modulow tak zeby sie nie pultalo
i zeby nie bylo niepotrzebnych zaleznosci.
dodatkowo warto przepisac na system zgodny z R6RS, o ile
w ogole jest to mozliwe (jakis mejlik do guile-user?)

Problem jest jeszcze jednej natury: jezeli mamy sobie
modul, ktory zalacza inny modul, merdzujac jednoczesnie
jego generyki, to co z generykami definiowanymi przez ow
"zewnetrzny" modul?


DO ZROBIENIA NA CZAS PODROZY:
1. klient laczy sie z serwerem v
2. klient prosi o wejscie do gry, otrzymujac potwierdzenie
3. w odpowiedzi klient otrzymuje swojego aktora (albo kilku
aktorow) v
4. klient pyta o widziane przez siebie podprzestrzenie.
w odpowiedzi otrzymuje liste podprzestrzeni i laczacych je
portali v 
5. dla kazdego widzianego sektora klient pyta o to, jakie
obiekty znajduja sie w nim (moze pytac albo o same identyfikatory,
o typy, o poszczegolne sloty, albo o wszystkie sloty) v
6. klient prosi o przesylanie zmian stanu obiektow.
Od tej pory serwer w kazdym cyklu zycia wysyla sloty tych
obiektow, ktore zostaly zmienione 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
możliwe zdarzenia z perspektywy klienta:
- nowy sektor staje się widoczny "(subspace-becomes-visible! id)"
- widziany wcześniej sektor przestaje być widoczny
"(subspace-no-longer-visible! id)"
- obiekt pojawia sie w sektorze "(new-object! sector-id id . slots)"
- obiekt znika z widzianego sektora "(remove-object! id)"
- obiekt zostaje przeniesiony z jednego widzianego sektora
do innego "(move-object! source-sector dest-sector)"

Kiedy wspomniane zdarzenia sa emitowane?
oczywiscie, w stosownym momencie.
najpierw następuje aktualizacja świata, a wszelkie zmiany
podprzestrzeni dopisywane są do odpowiedniej listy. następnie
procedura respond cyklu serwera wysyła -- w zaleźności od
widoczności -- jeden z powyższych komunikatów. Tadam!
HA! A jeszcze trzeba uwzglednic taka sytuacje, w ktorej w
danej podprzestrzeni pojawia sie albo znika portal!
Sprawa to niełatwa, więc niekoniecznie należy to robić teraz.

Kolejne rzeczy:
dodac pelniejsza semantyke schema do makra chain-request:
z network-3d-view, zeby mozna bylo wewnatrz uzywac ifow,
(condow?), named-letow i tego typu pierdol.

*************************************************************
Kliencka strona protokolu powinna posiadac tylko takie oto
komendy:
- response (dla requestow)
- issue (dla subskrypcji)

Transakcje powinny automatycznie (transparentnie) rozbijac zbyt
duze pakiety na mniejsze (po stronie serwera) i sklejac je
(po stronie klienta), totez pojecie transakcji nalezy do nizszej
warstwy niz żądania i prenumeraty

Również warto się zająć implementacją powtórzeń/timeoutów.

Ponownie namyslec sie nad wspomnianym sieciowym systemem obiektow:
mogloby sie okazac, ze zewnetrzny podzial na obiekty i podprzestrzenie
w ogole nie jest potrzebny.

Jezeli idzie o ogolny system obiektow, to byloby fajnie, gdyby dalo sie
tworzyc metody rozszerzalne, ale niezastepowalne, tj. tworzyc je w taki sposob,
ze jesli przeciazymy metode dla potomka jakiejs klasy, to owa metoda sama wywola
(na poczatku lub na koncu -- w zaleznosci od preferencji) next-method -- tworca
przeciazajacej metody nie powinien musiec sam niczego pisac.

URGENT STUFF:

- the system of subspaces, as implemented in
the original C++ version of goose (more or less). This
requires reimplementation (or, to be quite honest,
actual implementation) of the `objects-visible-to`
procedure from extra/goose.scm

- support for the primitive shapes + for displaying them,
and obviously for collision detection

- a framework for testing the validity of the specified
distance functions (I would like to be able to see the
distance of the geometrical primitives that I drag around
the screen). This is also a challenge to enhance slayer,
by creating text widgets that are updated when the objects
are moved around.

- also having some phsics equations would be pleasant

SERVER IDEAS:
- knowledge distribution: a client should know what things
are unknown, and should know how to ask for them. This requires
a more advanced inference mechanism, and so it will now only be
implemented in a very little extent, but the question is open
for the future

- timeout mechanism (the server stores the last time when it
received a message from a client, and if -- after sending a
warning -- it does not receive a confirmation -- it drops that
client. Very simple, although not very urgent, and might only
become meaningful if the world grows enough that it would take
the server a long time to load)

- subspaces in which the objects can see each other
(we assume for now, that the accessibility relation is symmetric
and reflexive, but not necessarily transitive; yet it would
be lovely to be able to define all possible configuratins within
the system, and all the descriptions should be equally simple)

TOFIX:
the <unique-id> object identifiers should be generated in some other way
than it is done now (now it uses the internal addresses that are given when 
an object is displayed). This has to do with the #< read syntax, thanks to
which one can send objects using the display function.
In general, however, this is wrong, because two servers can use the same
address to store different objects, and so it should be changed in the future
(see "make-client-protocol" in network.scm for details)

OVERALL IDEAS:
- implement command-line-option controlled mechanism 
for displaying messages and logs (for instance, to make
it possible to switch displaying all the packets that are
sent to the server, or just some of them). The mechanism
should be able to run on both client and server

EXCITING STUFF:
Think about an editor that would allow to make
changes within the world within the current goose
session. These would be specified in more detail by
the very goose protocol, but the target version
should be able to do the following:
- modify the map (planes, textures etc)
- create (design) new objects by merging shapes
and nodes
- the certain kind of nodes (namely, motors)
would enable the control over an object. The
owner of the object is in control and can send
messages to motors (it might happen, that two
or more players control one object)
- additionally, each object can have its eyecandies
associated (things like the exact model shapes, skins,
clothes and so forth)

EXTENDING GUILE:
- fix the hierarchy of vectors so that <uvec> is-a? <vector>
(it should make the following structure)
<array>
 ^  ^ \
 |  |   \
 |  |     \ <generalized-vector>
 |  |        ^  ^   ^         ^
 |  |        |  |   |         |
 |  |  <vector> | <bytevector>|
 |  |       <bitvector>   ^ <string>
 |  |                     |
 | <uniform-array>     <uvec>
 |  ^                    ^
 |  |- <u8array>         |- <u8vec>
 |  |- <u16array>        |- <u16vec>
 |  |- <u32array>        |- <u32vec>
 |  |- <u64array>        |- <u64vec>
 |  |- <s16array>        |- <s16vec>
 |  |- <s32array>        |- <s32vec>
 |  |- <s64array>        |- <s64vec>
 |  |- <f32array>        |- <f32vec>
 |  |- <f64array>        |- <f64vec>
 |  |- <c32array>        |- <c32vec>
 |  |- <c64array>        |- <c64vec>
 |
<shared-array>
- the reader syntax for uniform vectors/arrays
seems to suck, i.e. although one can write
(define x 5)
`#(,x ,x ,x)
and it works properly,
`#f32(,x ,x ,x)
doesn't behave as expected

- find out why 'define-symmetric-method' doesn't work when loaded
from an external module

- add quaternion type as described in an online document:
http://www.ccs.neu.edu/home/dorai/squat/squat.html

- support pattern matcher for goops classes

- there should be a define-method* form that would allow keyword
arguments, and in addition -- that would be able to make sure that
all inheriting methods call it (as a next-method) at the beginning
or at the end of themselves

BUGS:
- text-area widget renders way too much text,
there should be some sort of cache (which, in turn,
requires development of a more sophisticated object
system, especially for its serialization features)
- check the code for memory leaks
- each font should have a one one-pixel wide surface
associated that would be created for the empty text

FURTHER TODO (for the slayer mostly):

- redesign the input subsystem to be uniform (now there is one
C table, and some widgets may define ther own tables. The idea
is to make the C table an SCM vector, or conversely)

- the list-window is an input widget. typing
causes narrowing of available options
- among the options, there should be 'add button'
option, that causes the creation of a new button
on the stage
- left-click on the button causes the invocation
of the action (which is by default opening the
button's editor window)
- right-click on the button causes the option list
to appear. among the option list there are the following:
* edit action ...
* appearance ...
* delete

- ctrl+click on any object causes a highlight of that
object. pressing delete when an object is highlited
causes deletion of that object
